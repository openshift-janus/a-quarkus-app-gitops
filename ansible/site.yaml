---
- name: Gather Cluster Info.
  gather_facts: false
  hosts: 'localhost'
  tasks:
  - name: Determine Host
    shell: "oc cluster-info | grep -Eo '.cluster(.*?).com'"
    register: cluster_response
  - name: Extract Cluster
    set_fact:
      cluster_host: "{{ cluster_response.stdout }}"

- name: Create Kubernetes Secret for GPG_PUBLIC_KEY
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Set gpg_public_key by look up env 
      set_fact:
        # msg: "{{ lookup('env', 'GPG_PUBLIC_KEY')}}"
        gpg_public_key: "{{ lookup('env', 'GPG_PUBLIC_KEY')}}"
    - name: Check if GPG_PUBLIC_KEY environment variable exists
      assert:
        that:
          - gpg_public_key != ""
        fail_msg: "Please set variable GPG_PUBLIC_KEY using the following command export GPG_PUBLIC_KEY=$(gpg --armor --export yourgpgkey|base64) before proceeding with this playbook."
      tags: check_gpg_public_key

- name: Install a-quarkus-app CI pipeline via helm
  hosts: 'localhost'
  gather_facts: no
  tasks:
  - name: Wait for ArgoCD to be Ready
    kubernetes.core.k8s_info:
      api_version: argoproj.io/v1alpha1
      kind: ApplicationSet
    register: cm_crd
    until: cm_crd.api_found == true
    retries: 40
    delay: 5

  # Add private repo to argocd
  - name: Fetch ArgoCD admin password from Kubernetes Secret
    k8s_info:
      api_version: v1
      kind: Secret
      name: argocd-cluster
      namespace: "{{env.gitopsnamespace}}"
    register: secret_info
    tags:
      - add_private_repo
  # - name: debug
  #   debug:
  #     msg: {{secret_info}}
  - name: Set ArgoCD admin password
    set_fact:
      argocd_password: "{{ secret_info.resources[0].data['admin.password'] | b64decode }}"
    when: secret_info.resources | length > 0
    tags:
      - add_private_repo

  - name: Fail if ArgoCD admin password retrieval fails
    fail:
      msg: "Failed to retrieve ArgoCD admin password from Kubernetes Secret."
    when: secret_info.resources | length == 0
    tags:
      - add_private_repo

  - name: Fetch argocd Route
    # with_items: "{{ env }}"
    k8s_info:
      api_version: route.openshift.io/v1
      kind: Route
      name: argocd-server
      namespace: "{{env.gitopsnamespace}}"
      # label_selectors: 
      #   - app.kubernetes.io/name = argocd-server
    register: route_info
    tags:
      - add_private_repo
    # ignore_errors: yes

  - name: Extract argocd Route URL
    set_fact:
      argocd_route_url: "{{ route_info.resources[0].status.ingress[0].host }}"
    when: route_info.resources
    tags:
      - add_private_repo

  - name: Log in to ArgoCD and add private GitHub repo
    # with_items: "{{ env }}"
    shell: |
      argocd login {{ argocd_route_url }} --username=admin --password={{ argocd_password }} --insecure --grpc-web
      argocd repo add https://github.com/{{ env.githubrganization }}/{{env.appname}}-gitops.git --username {{ lookup('env', 'SCM_USERNAME') }} --password {{ lookup('env', 'SCM_PAT') }}
    tags:
      - add_private_repo

  - name: Apply ApplicationSet for a-quarkus-app pipeline Deployment
    # with_items: "{{ env }}"
    kubernetes.core.helm:
      state: present
      name: applicationset
      namespace: "{{ env.gitopsnamespace }}"
      chart_ref: ../helm/applicationset
      values:
          applicationset:
            namespace: "{{env.gitopsnamespace}}"
          helm_params:
            argocd:
              namespace: "{{env.gitopsnamespace}}"
            build:
              cluster_subdomain: "{{ cluster_host[1:] }}"
              maven:
                maven_builder_image: "{{env.maven_builder_image}}"
            dev:
              destination:
                server: "https://kubernetes.default.svc"
                namespace: "{{env.appname}}-dev"
            test:
              destination:
                server: "https://kubernetes.default.svc"
                namespace: "{{env.appname}}-test"
            prod:
              destination:
                server: "https://kubernetes.default.svc"
                namespace: "{{env.appname}}-prod"

- name: Wait for Application's Kubernetes Namespace to Exist
  hosts: localhost
  # gather_facts: no
  tasks:
    - name: Check if the namespace exists
      # with_items: "{{ env }}"
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Namespace
        name: "{{env.appname}}-dev"
      register: namespace_info
      until: namespace_info.resources
      retries: 60
      delay: 5
      tags:
        - wait_namespace

    - name: Debug Namespace Info
      debug:
        # msg: "{{namespace_info.resources}}" 
        var: namespace_info
      tags:
        - wait_namespace

- name: Post configuration for create secret, triggerbinding etc
  hosts: localhost
  tasks:
  - name: Create Kubernetes Secret
    k8s:
      definition:
        apiVersion: v1
        kind: Secret
        metadata:
          name: gpg-public-key
          namespace: "{{env.appname}}-dev"
        data:
          public.key: "{{ lookup('env', 'GPG_PUBLIC_KEY') }}"
      state: present
    when: gpg_public_key != ""
    tags: create_secret

  - name: Fetch Sonarqube OpenShift Route
    k8s_info:
      api_version: route.openshift.io/v1
      kind: Route
      namespace: "{{env.sonarnamespace}}"
      label_selectors: 
        - app = sonarqube
    register: sonarqube_route_info
    ignore_errors: true

  - name: Fail if route doesn't exist
    fail:
      msg: "Failed to fetch OpenShift Route URL for SonarQube. Ensure the route with label 'app: sonarqube' exists in the 'sonarqube' namespace."
    when: not sonarqube_route_info.resources
  - name: Extract sonarqube Route URL
    set_fact:
      sonarqube_route_url: "{{ sonarqube_route_info.resources[0].status.ingress[0].host }}"
    when: sonarqube_route_info.resources
  - name: Check if sonarqube_access_token Secret exists
    k8s_info:
      kind: Secret
      name: sonarqube-access-token
      namespace: "{{env.appname}}-dev"
    register: secret_info
    ignore_errors: true
  
  - name: debug
    debug:
      msg: "{{secret_info}}"

  - name: Generate SonarQube Access Token
    uri:
      url: "https://{{sonarqube_route_url}}/api/user_tokens/generate?name=a_quarkus_app_project_token"
      method: POST
      user: "admin"
      password: "admin"
      force_basic_auth: true
      status_code: 200
      return_content: yes
    register: token_response
    when: not secret_info.resources

  - name: Extract Token Value
    set_fact:
      token_value: "{{ token_response.json.token }}"
    when: not secret_info.resources

  - name: Create or Update sonarqube_access_token Secret
    k8s:
      definition:
        apiVersion: v1
        kind: Secret
        metadata:
          name: sonarqube-access-token
          namespace: "{{env.appname}}-dev"
        data:
          token: "{{ token_value | b64encode }}"
      state: present
    when: not secret_info.resources

  - name: Fetch quay Route
    k8s_info:
      api_version: route.openshift.io/v1
      kind: Route
      name: quay-quay
      namespace: "{{ env.quaynamespace}}"
    register: route_info
    tags:
      - quay_route

    # - name: debug
    #   debug:
    #     msg: {{route_info}}

  - name: Extract quay Route URL
    set_fact:
      quay_route_url: "{{ route_info.resources[0].status.ingress[0].host }}"
    when: route_info.resources
    tags:
      - quay_route

  - name: Fetch Nexus Svc
    k8s_info:
      api_version: v1
      kind: Service
      name: nexus-sonatype-nexus-service
      namespace: "{{ env.nexusnamespace}}"
    register: nexus_svc_info
    tags:
      - nexus_svc_info
  - name: debug
    debug:
      var: nexus_svc_info
    tags:
      - nexus_svc_info

  - name: Extract quay Route URL
    set_fact:
      nexus_svc_url: "{{ nexus_svc_info.resources[0].metadata.name }}.{{env.nexusnamespace}}.svc"
      nexus_svc_port: "{{ nexus_svc_info.resources[0].spec.ports[0].port }}"
    when: nexus_svc_info.resources
    tags:
      - nexus_svc_info

  - name: Create or Update TriggerBindings for your app
    k8s:
      definition:
        apiVersion: triggers.tekton.dev/v1beta1
        kind: TriggerBinding
        metadata:
          name: "{{ env.appname }}-binding"
          namespace: "{{env.appname}}-dev"
          annotations:
            generated_by: ansible_playbook
        spec:
          params:
          - name: maven_mirror_url
            value: 'http://{{nexus_svc_url}}:{{nexus_svc_port}}/repository/maven-public'
          - name: sonarqube_host_url
            value: "https://{{sonarqube_route_url}}"
          - name: tls_verify
            value: "true"
          - name: image_dev_repo
            value: "https://{{ quay_route_url}}/develop/{{env.appname}}"
      state: present
    tags:
      - triggerbinding
